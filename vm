#!/usr/bin/perl
# Manages virtual machines.
# TODO: isolated network

# TODO: fix netopt
# TODO: make netdriver opts

# TODO: multi-opt networks and drives
# TODO: support multiple netdrivers (separate -device and -netdev parts in args)
# TODO: handle static ip address with route and such? and dhcp?
# TODO: hubport?
# https://www.suse.com/documentation/sles11/book_kvm/?page=/documentation/sles11/book_kvm/data/cha_qemu_running_networking.html

use strict;
use warnings;
use autodie;
use English;
use v5.20;
use Getopt::Long qw( :config posix_default bundling no_ignore_case );
use File::Path qw( mkpath );
use File::Temp qw( tempfile );

sub needs_root {
	my $msg = shift;
	if ($EUID != 0) {
		die "$msg needs root.";
	}
}

# See usage for more info.
my %PRESETS = (
	archinstall    => { subdir => 'archinstall', display => 'curses', image => 'archinstall.iso' },
	blackarch      => { subdir => 'blackarch', image => 'blackarch.iso' },
	tails          => { subdir => 'tails', cdrom => 'tails.iso' },
	# TODO: isolate with tap+ip (even though user-mode networking acts as a firewall)
	metasploitable => { subdir => 'metasploitable', image => 'metasploitable.iso' },
	'xp-home'      => { subdir => 'xp-home-sp1', maindisk => 1, kvm => 0, networks => 'none' }
	# TODO: let's start making simple application isolation VMs
	#       for the sake of speed, maybe we can use user-mode networking with guestfwd
);

my %DEFAULTS = (
	arch      => 'x86_64',
	kvm       => 1,
	mem       => '6G',
	smp       => '1',
	bootopts  => 'order=dc',
	display   => 'sdl',
	networks  => 'user',
	netopts  => '',
	netdriver => 'virtio-net',
	share     => 'none',
	basedir   => $ENV{HOME} . '/vm',
	#subdir   => '<none>',
	maindisk  => 0,
	makemain  => 0,
	mainsize  => '20G',
	snapshot  => 1,
	#snaplist  not a setting
	#revert    not a setting
	#cdrom    => '<none>',
	#drives   => '<none>',
	iodriver  => 'virtio',
	#image    => '<none>',
);

my %NETWORKS;
my %DISPLAYS;
sub usage {
	my @preset_names = keys %PRESETS;
	my @display_names = keys %DISPLAYS;
	my @network_names = keys %NETWORKS;

	$" = ', ';
	print <<HELP;
usage: vm [options]

Parameters (+ requires a value):
 NAME       DEFAULT     FLAG  OPTIONS
 preset     <none>      -p+   @preset_names
 basedir    ~/vm        -v+   directory name
 subdir     <none>      -o+   directory name

BASE SYSTEM
 arch       x86_64      -a+   various
 kvm        true        -k    (toggle)
 mem        6G          -m+   various
 smp        1           -s+   various
 bootopts   order=dc    -B+   see qemu(1)

DISPLAY
 display    sdl         -d+   @display_names

NETWORK
 networks   user        -n+   @network_names (comma-separated)
 netopts    <none>      -N    see qemu(1)
 netdriver  virtio-net  -D    see qemu -device help
 share      none        -H+   smb, virtfs, none

MAINDISK
 maindisk   false       -i    (toggle)
 makemain   false       -C    (toggle)
 mainsize   20G         -z    size of maindisk
 snapshot   true        -S    (toggle)
 snaplist               -L    (action)
 revert     <none>      -R+   snapshot to revert to

OTHER MEDIA
 cdrom      <none>      -c+   cdrom file
 drives     <none>      -r+   comma-separated drive files (e.g. /dev/sda)
 iodriver   virtio      -I+   virtio, ide, scsi, sd, others
 image      <none>      -f+   image file

META
 passon     <none>      -P+   dashless comma-separated flags to pass to qemu
 viewcmd    0           -V    (toggle)
 help       0           -h    (toggle)
HELP
	$" = ' ';
}

my %opts;
GetOptions(\%opts,
           'preset|p=s',
           'basedir|v=s',
           'subdir|o=s',
           'arch|a=s',
           'kvm|k!',
           'mem|m=s',
           'smp|s=s',
           'bootopts|B=s',
           'display|d=s',
           'networks|n=s',
           'netopts|N=s',
           'netdriver|D=s',
           'share|H=s',
           'maindisk|i!',
           'makemain|C!',
           'mainsize|z!',
           'snapshot|S!',
           'snaplist|L',
           'revert|R=s',
           'cdrom|c=s',
           'drives|r=s',
           'iodriver|I=s',
           'image|f=s',
           'passon|P=s',
           'viewcmd|V!',
           'help|h');

# Handle preset.
my %preset;
if (defined $opts{preset}) {
	my $preset = $PRESETS{$opts{preset}};
	if (!$preset) {
		die "invalid preset: $opts{preset}"
	}
	%preset = %$preset;
}

# Merge in the defaults and preset.
my %settings = (%DEFAULTS, %preset, %opts);

my $vmdir;
if (defined $settings{subdir}) {
	$vmdir = "$settings{basedir}/$settings{subdir}";
} else {
	$vmdir = '.';
}

# This is the argument list passed to qemu.
my @args;

# -----------------------------------------------------------------------------
# <BASE SYSTEM>
# -----------------------------------------------------------------------------
if ($settings{kvm}) {
	needs_root 'KVM';
	push @args, '-enable-kvm';
}

push @args, '-m', $settings{mem};

push @args, '-smp', $settings{smp};

push @args, '-boot', $settings{bootopts};
# -----------------------------------------------------------------------------
# </BASE SYSTEM>
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# <DISPLAY>
# -----------------------------------------------------------------------------
%DISPLAYS = (
	sdl     => ['-vga', 'std', '-display', 'sdl'],
	spice   => ['-vga', 'qxl', '-spice', 'port=5900,addr=127.0.0.1,disable-ticketing'],
	curses  => ['-vga', 'std', '-display', 'curses'],
	gtk     => ['-vga', 'std', '-display', 'gtk'],
	console => ['-nographic'],
	none    => ['-vga', 'none', '-display', 'none'],
);

my $display = $DISPLAYS{$settings{display}};
die "invalid display: $settings{display}" if (!$display);
push @args, @$display;
# -----------------------------------------------------------------------------
# </DISPLAY>
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# <NETWORK>
# -----------------------------------------------------------------------------
if ($settings{netdriver} =~ /virtio-net/) {
	needs_root 'virtio-net';
}

sub dhcp {
	my ($if, $range) = @_;

    system 'dnsmasq',
	  '--strict-order',
	  "--interface=$if",
	  '--except-interface=lo',
	  #"--listen-address=192.168.0.1",
	  '--bind-interfaces',
	  "--dhcp-range=$range",
	  '--conf-file=/dev/null',
	  "--pid-file=/var/run/qemu-dnsmasq-$if.pid",
	  "--dhcp-leasefile=/var/run/qemu-dnsmasq-$if.leases",
	  '--dhcp-no-override';
}

sub dhcp_kill {
	my ($if) = @_;

	open my ($pid_file), '<', "/var/run/qemu-dnsmasq-$if.pid" or die $!;
	my $pid = <$pid_file>;
	kill 'TERM', int($pid);
}

my $sharedir = "$vmdir/shared";
if ($settings{share} eq 'smb') {
	mkpath "$sharedir";
	# TODO: apply to netopts instead. this is deprecated
	push @args, '-smb';
} elsif ($settings{share} eq 'virtfs') {
	mkpath "$sharedir";
	push @args, '-virtfs', "local,path=$sharedir,security_model=mapped-file,mount_tag=share";
} elsif ($settings{share} eq 'none') {
	# do nothing
} else {
	die "invalid share type: $settings{share}";
}

sub net_pre_hook_tor {
	# tor
	system 'systemctl', 'start', 'tor';

	# bridge
	system 'brctl', 'addbr', 'tor';
	system 'ip', 'link', 'set', 'tor', 'up';
	system 'ip', 'addr', 'add', '192.168.0.1/24', 'dev', 'tor';

	# dhcp
	dhcp 'tor', '192.168.0.2,192.168.0.2';

	# rinetd
	my ($rinetd_conf, $rinetd_conf_name) = tempfile();
	print $rinetd_conf <<EOF;
192.168.0.1     9050            127.0.0.1       9050
EOF
	system 'rinetd', '-c', $rinetd_conf_name;
}

sub net_post_hook_tor {
	my $pid;

	# rinetd
	open my $rinetd_pid_file, '<', '/var/run/rinetd.pid';
	$pid = <$rinetd_pid_file>;
	kill 'TERM', $pid;

	# dhcp
	dhcp_kill 'tor';

	# bridge
	system 'ip', 'link', 'set', 'tor', 'down';
	system 'brctl', 'delbr', 'tor';

	# tor
	system 'systemctl', 'stop', 'tor';
}

%NETWORKS = (
	# needs_root, pre_hook, post_hook, netdev, device
	user   => { netdev => ['-netdev', "user,id=user"], device => ['-device', "$settings{netdriver},netdev=user"] },
	bridge => { needs_root => 1, netdev => ['-netdev', "bridge,id=bridge,$settings{netopts}"],
	            device => ['-device', "$settings{netdriver},netdev=bridge"] },
	tor    => { needs_root => 1, pre_hook => \&net_pre_hook_tor, post_hook => \&net_post_hook_tor,
	            netdev => ['-netdev', 'bridge,id=tor,br=tor'], device => ['-device', "$settings{netdriver},netdev=tor"] },
	#tap   => { needs_root => 1, netdev => ['-netdev', 'tap,id=net0'], device => ['-device', "$settings{netdriver},netdev=net0"] },
	none   => { netdev => ['-net', 'none'], device => [] },
	dump   => { netdev => ['-net', "dump,file=$vmdir/dump.pcap"] },
);

my @networks = split /,/, $settings{networks};

foreach my $network_name (@networks) {
	my $network = $NETWORKS{$network_name};
	if (!$network) {
		die "invalid network: $network_name";
	}
	if ($network->{needs_root}) {
		needs_root "network $network_name";
	}
	push @args, @{$network->{netdev}}, @{$network->{device}};
}
# -----------------------------------------------------------------------------
# </NETWORK>
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# <MAINDISK>
# -----------------------------------------------------------------------------
my $maindisk = "$vmdir/maindisk.qcow2";

if ($settings{maindisk}) {
	if (!-e $maindisk) {
		if ($settings{makemain}) {
			system 'qemu-img', 'create', '-f', 'qcow2', $maindisk, $settings{mainsize};
		} else {
			die "maindisk ($maindisk) does not exist. use -C to create it."
		}
	} elsif (!-r $maindisk) {
		die "could not read maindisk ($maindisk)";
	}

	# Handle snaplist command.
	if (defined $opts{snaplist}) {
		# TODO: test
		system 'qemu-img', 'snapshot', '-l', $maindisk;
		exit;
	}

	# TODO: add an option to delete the last snapshot
	# Handle revert command.
	if (defined $opts{revert}) {
		# TODO: test
		system 'qemu-img', 'snapshot', '-a', $opts{revert}, $maindisk;
		exit;
	}

	# TODO: support device-specific iodrivers   e.g. /dev/sda:ide
	push @args, '-drive', "file=$maindisk,cache=none,if=$settings{iodriver}"
}
# -----------------------------------------------------------------------------
# </MAINDISK>
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# <OTHER MEDIA>
# -----------------------------------------------------------------------------
if (defined $settings{cdrom}) {
	push @args, '-cdrom', "$vmdir/$settings{cdrom}";
}
if (defined $settings{drives}) {
	my @drives = split /,/, $settings{drives};
	push @args, map { ('-drive', "file=$_,cache=none,if=virtio") } @drives;
}
if (defined $settings{image}) {
	push @args, "$vmdir/$settings{image}";
}
# -----------------------------------------------------------------------------
# </OTHER MEDIA>
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# <META>
# -----------------------------------------------------------------------------
if (defined $settings{passon}) {
	push @args, map { "-$_" } split /,/, $settings{passon};
}

# We handle help down here because &usage lists networks and displays.
if (defined $opts{help}) {
	&usage;
	exit;
}
# -----------------------------------------------------------------------------
# </META>
# -----------------------------------------------------------------------------

if (!($settings{maindisk} || defined $settings{cdrom} || defined $settings{image})) {
	die 'no potential boot media found. you must specify at least one of: maindisk, cdrom, image.'
}


# Network hooks
foreach my $network_name (@networks) {
	my $network = $NETWORKS{$network_name};

	if ($network->{pre_hook}) {
		say "running pre_hook for $network_name...";
		&{$network->{pre_hook}};
	}
}

# TODO: handle snapshot
if ($settings{viewcmd}) {
	say "qemu-system-$settings{arch} @args";
	sleep 1;
} else {
	system "qemu-system-$settings{arch}", @args;
}

# Network hooks
foreach my $network_name (@networks) {
	my $network = $NETWORKS{$network_name};

	if ($network->{post_hook}) {
		say "running post_hook for $network_name...";
		&{$network->{post_hook}};
	}
}
