#!/bin/bash

if [[ $# = 0 ]] ; then
	echo "Invalid number of arguments." >&2
	exit 1
fi

if [[ $1 = -h ]] ; then
	echo "$(basename "$0") [-h|-l]"
	exit
elif [[ $1 = -l ]] ; then
	echo "Shared: arc, ela, ext (cod), med, ro, sec."
	echo "Backup: etc"
	echo "Other: gpg"
	exit
fi

local_name="$(uname -n)"
local_root="$HOME"
#remote_name="locserv"
#remote_root="${local_root}"
remote_name=
remote_root="/home/evan/test/te"

local="${local_name}:${local_root}"
if [[ -z ${remote_name} ]] ; then
	remote="${remote_root}"
else
	remote="${remote_name}:${remote_root}"
fi
remote_bu_dir="${remote_root}/bu/${local_name}"

rs_flags="-avzy --progress -e ssh"
crypt=false

# Out or in
if [[ $1 == out ]] ; then
	out=true
elif [[ $1 == out-crypt ]] ; then
	out=true
	crypt=true
	# Force gpg to use curses pinentry
	#unset DISPLAY
elif [[ $1 == in ]] ; then
	out=false
else
	echo "First argument must be the direction (out or in)." >&2
	exit 1
fi

# Info
if $out ; then
	echo "Syncing outwards."
	action="Backing up"
else
	echo "Syncing inwards."
	action="Pulling in"
fi
echo "Local sync root is '$local'"
echo "Remote sync root is '$remote'"
echo "Remote backup directory is '$remote_bu_dir'"
echo

sync_item() {
	local_item="$1"
	remote_item="$2"

	cd "$local_root"

	if $delete && ! $crypt ; then
		delete_flags="--delete-after"
	else
		delete_flags=
	fi

	echo "$action $(basename "${local_item}") (${local_name}:${local_item}) with ${remote_item}..."
	if $out ; then
		if $crypt ; then
			if [[ -z $remote_name ]] ; then
				tar c "$local_item" | gpg -c > "$remote_root/$remote_item.tar.gpg"
			else
				tar c "$local_item" | gpg -c | ssh "$remote_name" "cat > $remote_root/$remote_item.tar.gpg"
			fi
		else
			rsync $rs_flags $delete_flags "$local_item/" "$remote/$remote_item"
		fi
	else
		rsync $rs_flags $delete_flags "$remote/$remote_item/" "$local_item"
	fi
}

for arg ; do
	if [[ "$arg" == -* ]] ; then
		delete=true
		arg=${arg:1}
		if $crypt ; then
			echo "Deletion has no effect on crypt."
		else
			echo "Warning: deletion set on $arg."
		fi
	else
		delete=false
	fi

	case "$arg" in
		all|arc) sync_item "arc" "arc"                       ;;&
		all|ela) sync_item "ela" "ela"                       ;;&
		all|ext) sync_item "ecod" "ecod"                     ;;&
		all|med) sync_item "med" "med"                       ;;&
		all|ro)  sync_item "ro" "ro"                         ;;&
		all|sec) sync_item ".sec.tar.gz.gpg" ".sec.tar.gz.gpg" ;;&
		all|etc)
			echo "$action etc..."

			cd /
			if $out ; then
				if $delete ; then
					delete_command="rm -rf ${remote_bu_dir}"
				else
					delete_command="false"
				fi

				pacman -Qii | grep '^MODIFIED' | grep -v '^shadow$' | cut -d$'\t' -f2 | sed 's/^.//' |
				xargs tar -cz |
				ssh $remote_name "${delete_command}; mkdir -p ${remote_bu_dir}; tar -xz -C ${remote_bu_dir}"
			else
				if $delete ; then
					echo "Deletion is not permitted on etc pulls." >&2
				fi

				echo "Note: etc pulls pull files into ${local_root}/etc."
				echo "It is the user's responsibility to copy these files into /etc."
				mkdir -p ${local_root}/etc && cd ${local_root}/etc &&
				ssh $remote_name "cd ${remote_bu_dir} && tar -cz *" | tar -xz
			fi
			;;&
		all|gpg)
			echo "$action gpg private keys..."
			if $out ; then
				gpg --export-secret-keys | ssh $remote_name "gpg --import"
			else
				ssh $remote_name "gpg --export-secret-keys" | gpg --import
			fi
			;;
		#*)
			#   echo "Invalid: $arg"
			#   ;;
	esac
done
