#!/bin/bash

if [[ $# = 0 ]] ; then
	echo "Invalid number of arguments." >&2
	exit 1
fi

if [[ $1 = -h ]] ; then
	cat <<EOF
$(basename "$0") [-h] DIRECTION GROUP/ITEM...

Directions:
    'out' backs up files
    'out-crypt' symmetrically encrypts files and backs them up
    'in' syncs in backups

Group 'all' (normal backup routine) contains these items:
    arc, ela, ecod, med, ro, etc
Group 'alt' (items normally backed up through other means) contains these items:
    cod, fil, ecad, cad, jnt

Normal items are like aliases for directories. Most items are home
directory root directories.

There is one special item:
    'etc' performs a backup of modified pacman-provided files.
EOF
	exit 1
fi

local_name="$(uname -n)"
local_root="$HOME"
remote_name="locserv"
remote_root="${local_root}"
#remote_name=
#remote_root="/mnt/$(whoami)"

rs_flags="-avzy --progress -e ssh"
crypt=false

local="${local_name}:${local_root}"
if [[ -z ${remote_name} ]] ; then
	remote="${remote_root}"
else
	remote="${remote_name}:${remote_root}"
fi
remote_bu_dir="${remote_root}/bu/${local_name}"

# Out or in
# TODO: add out-dryrun
if [[ $1 == out ]] ; then
	out=true
elif [[ $1 == out-crypt ]] ; then
	out=true
	crypt=true
	# Force gpg to use curses pinentry
	unset DISPLAY
	# This allows gpg pinentry to work if gpg is writing to a redirected or
	#  piped stdout
	export GPG_TTY=$(tty)
	# TODO: try to make this more secure
	echo -n "Encryption passphrase (blank to use gpg interactively): "
	read -s crypt_passphrase
	echo

	if [[ -z "$crypt_passphrase" ]] ; then
		# gpg interacts with the user by default
		gpg_flags=
	else
		echo -n "Enter passphrase again: "
		read -s crypt_passphrase_conf
		echo
		if [[ "$crypt_passphrase_conf" != "$crypt_passphrase" ]] ; then
			echo "Passphrases do not match"
			exit 1
		fi
		gpg_flags="--yes --batch --passphrase $crypt_passphrase"
	fi
elif [[ $1 == in ]] ; then
	out=false
else
	echo "First argument must be the direction (out[-crypt] or in)." >&2
	exit 1
fi

# Info
if $out ; then
	echo "Syncing outwards."
	action="Backing up"
else
	echo "Syncing inwards."
	action="Pulling in"
fi
echo "Local sync root is '$local'"
echo "Remote sync root is '$remote'"
echo "Remote backup directory is '$remote_bu_dir'"
echo

sync_item() {
	local_item="$1"
	remote_item="$2"

	cd "$local_root"

	if $delete && ! $crypt ; then
		delete_flags="--delete-after"
	else
		delete_flags=
	fi

	echo "$action ${local}/${local_item} with ${remote}/${remote_item}..."
	if $out ; then
		if $crypt ; then
			if [[ -z $remote_name ]] ; then
				# Write directly to a location if there's no remote machine
				tar c "$local_item" |
				gpg $gpg_flags -o - -c > "$remote_root/$remote_item.tar.gpg"
			else
				# Pipe through ssh if the location is on a remote machine
				# TODO: support ftp
				tar c "$local_item" | gpg $gpg_flags -o - -c |
				ssh "$remote_name" "cat > $remote_root/$remote_item.tar.gpg"
			fi
		else
			rsync $rs_flags $delete_flags "$local_item/" "$remote/$remote_item"
		fi
	else
		rsync $rs_flags $delete_flags "$remote/$remote_item/" "$local_item"
	fi
}

for arg in "${@:2}" ; do
	if [[ "$arg" == -* ]] ; then
		delete=true
		arg=${arg:1}
		if $crypt ; then
			echo "Deletion has no effect on crypt."
		else
			echo "Warning: deletion set on $arg."
		fi
	else
		delete=false
	fi

	case "$arg" in
		all|arc) sync_item "arc" "arc"    ;;&
		all|ela) sync_item "ela" "ela"    ;;&
		all|ecod) sync_item "ecod" "ecod" ;;&
		all|med) sync_item "med" "med"    ;;&
		all|ro)  sync_item "ro" "ro"      ;;&
		dat) sync_item "/dat" "../../dat" ;;&
		alt|cod) sync_item "cod" "cod"    ;;&
		alt|fil) sync_item "fil" "fil"    ;;&
		alt|ecad) sync_item "ecad" "ecad" ;;&
		alt|cad) sync_item "cad" "cad"    ;;&
		alt|jnt) sync_item "jnt" "jnt"    ;;&
		sites) sync_item "sites" "sites"  ;;&
		all|etc)
			# TODO: make this compatible with locations on the same machine
			echo "$action etc..."

			cd /
			if $out ; then
				if $delete ; then
					delete_command="rm -rf ${remote_bu_dir}"
				else
					delete_command="false"
				fi

				# TODO: just leave these tarred up
				# TODO: don't bother with pacman
				pacman -Qii | grep '^MODIFIED' | grep -v '^shadow$' | cut -d$'\t' -f2 |
				sed 's/^.//' | xargs tar -cz |
				ssh $remote_name "${delete_command}; mkdir -p ${remote_bu_dir};"\
				                 "tar -xz -C ${remote_bu_dir}"
			else
				if $delete ; then
					echo "Deletion is not permitted on etc pulls." >&2
				fi

				echo "Note: etc pulls pull files into ${local_root}/etc."
				echo "It is the user's responsibility to copy these files into /etc."
				mkdir -p ${local_root}/etc && cd ${local_root}/etc &&
				ssh $remote_name "cd ${remote_bu_dir} && tar -cz *" | tar -xz
			fi
			;;&
		#*)
		#   echo "Invalid: $arg"
		#   ;;
	esac
done
